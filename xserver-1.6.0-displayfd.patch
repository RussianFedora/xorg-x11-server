From f14a89c627d9c4d790cc6785dd6628c9bda1c317 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 18 Jun 2009 16:56:41 +1000
Subject: [PATCH 3/9] displayfd hack

---
 dix/globals.c    |    1 +
 include/opaque.h |    1 +
 os/connection.c  |   73 +++++++++++++++++++++++++++++++++++++-----------------
 os/utils.c       |   11 ++++++++
 4 files changed, 63 insertions(+), 23 deletions(-)

diff --git a/dix/globals.c b/dix/globals.c
index 0a6b170..0ee83c0 100644
--- a/dix/globals.c
+++ b/dix/globals.c
@@ -126,6 +126,7 @@ int defaultColorVisualClass = -1;
 int monitorResolution = 0;
 
 char *display;
+int displayfd;
 char *ConnectionInfo;
 
 CARD32 TimeOutValue = DEFAULT_TIMEOUT * MILLI_PER_SECOND;
diff --git a/include/opaque.h b/include/opaque.h
index 5c70717..f23203f 100644
--- a/include/opaque.h
+++ b/include/opaque.h
@@ -50,6 +50,7 @@ extern _X_EXPORT int ScreenSaverAllowExposures;
 extern _X_EXPORT int defaultScreenSaverBlanking;
 extern _X_EXPORT int defaultScreenSaverAllowExposures;
 extern _X_EXPORT char *display;
+extern _X_EXPORT int displayfd;
 
 extern _X_EXPORT int defaultBackingStore;
 extern _X_EXPORT Bool disableBackingStore;
diff --git a/os/connection.c b/os/connection.c
index 0c580ab..1acdb7f 100644
--- a/os/connection.c
+++ b/os/connection.c
@@ -145,6 +145,7 @@ Bool AnyClientsWriteBlocked;	/* true if some client blocked on write */
 static Bool RunFromSmartParent;	/* send SIGUSR1 to parent process */
 Bool RunFromSigStopParent;	/* send SIGSTOP to our own process; Upstart (or
 				   equivalent) will send SIGCONT back. */
+static char dynamic_display[7];
 Bool PartialNetwork;	/* continue even if unable to bind all addrs */
 static Pid_t ParentProcess;
 
@@ -356,11 +357,26 @@ NotifyParentProcess(void)
 	    kill (ParentProcess, SIGUSR1);
 	}
     }
+    if (dynamic_display[0])
+	write(displayfd, dynamic_display, strlen(dynamic_display));
+
     if (RunFromSigStopParent)
 	raise (SIGSTOP);
 #endif
 }
 
+static Bool
+TryCreateSocket(int num, int *partial)
+{
+    char port[20];
+
+    sprintf(port, "%d", num);
+
+    return _XSERVTransMakeAllCOTSServerListeners(port, partial,
+						 &ListenTransCount,
+						 &ListenTransConns);
+}
+
 /*****************
  * CreateWellKnownSockets
  *    At initialization, create the sockets to listen on for new clients.
@@ -371,7 +387,6 @@ CreateWellKnownSockets(void)
 {
     int		i;
     int		partial;
-    char 	port[20];
 
     FD_ZERO(&AllSockets);
     FD_ZERO(&AllClients);
@@ -386,32 +401,44 @@ CreateWellKnownSockets(void)
 
     FD_ZERO (&WellKnownConnections);
 
-    sprintf (port, "%d", atoi (display));
-
-    if ((_XSERVTransMakeAllCOTSServerListeners (port, &partial,
-	&ListenTransCount, &ListenTransConns) >= 0) &&
-	(ListenTransCount >= 1))
+    if (display)
     {
-	if (!PartialNetwork && partial)
-	{
-	    FatalError ("Failed to establish all listening sockets");
-	}
-	else
+	if (TryCreateSocket(atoi(display), &partial) &&
+	    (ListenTransCount >= 1))
+	    if (!PartialNetwork && partial)
+		FatalError ("Failed to establish all listening sockets");
+    }
+    else /* -displayfd */
+    {
+	Bool found = 0;
+	for (i = 0; i < 65535 - 1024; i++)
 	{
-	    ListenTransFds = malloc(ListenTransCount * sizeof (int));
-
-	    for (i = 0; i < ListenTransCount; i++)
+	    if (!TryCreateSocket(i, &partial) && !partial)
 	    {
-		int fd = _XSERVTransGetConnectionNumber (ListenTransConns[i]);
-		
-		ListenTransFds[i] = fd;
-		FD_SET (fd, &WellKnownConnections);
-
-		if (!_XSERVTransIsLocal (ListenTransConns[i]))
-		{
-		    DefineSelf (fd);
-		}
+		found = 1;
+		break;
 	    }
+	    else
+		CloseWellKnownConnections();
+	}
+	if (!found)
+	    FatalError("Failed to find a socket to listen on");
+	sprintf(dynamic_display, "%d\n", i);
+	display = dynamic_display;
+    }
+
+    ListenTransFds = xalloc (ListenTransCount * sizeof (int));
+
+    for (i = 0; i < ListenTransCount; i++)
+    {
+	int fd = _XSERVTransGetConnectionNumber (ListenTransConns[i]);
+
+	ListenTransFds[i] = fd;
+	FD_SET (fd, &WellKnownConnections);
+
+	if (!_XSERVTransIsLocal (ListenTransConns[i]))
+	{
+	    DefineSelf (fd);
 	}
     }
 
diff --git a/os/utils.c b/os/utils.c
index 36cb46f..6338860 100644
--- a/os/utils.c
+++ b/os/utils.c
@@ -660,6 +660,17 @@ ProcessCommandLine(int argc, char *argv[])
 	    else
 		UseMsg();
 	}
+	else if (strcmp(argv[i], "-displayfd") == 0)
+	{
+	    if (++i < argc)
+	    {
+		displayfd = atoi(argv[i]);
+		display = NULL;
+		nolock = TRUE;
+	    }
+	    else
+		UseMsg();
+	}
 #ifdef DPMSExtension
 	else if ( strcmp( argv[i], "dpms") == 0)
 	    /* ignored for compatibility */ ;
-- 
1.7.4.4

